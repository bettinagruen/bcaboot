% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bcajack2.R
\name{bcajack2}
\alias{bcajack2}
\title{Nonparametric bias-corrected and accelerated bootstrap
confidence limits}
\usage{
bcajack2(x, B, func, ..., m = nrow(x), mr, pct = 0.333, K = 2,
  J = 12, alpha = c(0.025, 0.05, 0.1, 0.16, 0.5, 0.84, 0.9, 0.95,
  0.975), verbose = TRUE, sw = 0)
}
\arguments{
\item{x}{an nxp data matrix, rows are observed p-vectors, assumed
to be independently sampled from target population. If \code{p} is 1
then x can be a vector.}

\item{B}{number of bootstrap replications. 'B' can also be a vector
of B bootstrap replications of the estimated parameter of
interest, computed separately. If B is \code{Blist} as
explained above, x is not needed.}

\item{func}{function \eqn{\hat{\theta}}=func(x) computing estimate of the
parameter of interest; func(x) should return a real value for
any n' x p matrix x', n' not necessarily equal to n.}

\item{...}{additional arguments for func.}

\item{m}{integer m <= n; collects the n rows of x into m groups to
speed up the jackknife calculations for estimating the
acceleration value 'a'; typically m=20 or 40; does not have to
exactly divide n.}

\item{mr}{if m < n then mr repetions of the randomly grouped
jackknife calculations are averaged.}

\item{K}{If K > 0, bcajack also returns estimates of 'internal
standard error', that is, of the variability due to stopping at
B bootstrap replications rather than going on to
infinity. These are obtained from a second type of jackknifing,
taking an average of K separate jackknife estimates, each
randomly splitting the B bootstrap replications into J groups.}

\item{J}{the number of groups into which the bootstrap replications are split}

\item{alpha}{percentiles desired for the bca confidence limits.}

\item{verbose}{logical for verbose messages}

\item{sw}{switch that controls output, eg sw=5 returns the B
bootstrap replications as well as the bca output.}
}
\description{
\code{bcajack2} is a version of \code{bcajack} that allows
all the recomputations of the original statistic function
\code{func} to be carried out separately. This is an advantage
if \code{func} is time-consuming, in which case the B
replications for the nonparametric bca calculations might need
to be done on a distributed basis.

To use bcajack2 in this mode, we first compute a list \code{Blist}
via \code{Blist <- list(Y = Y,tt = tt,t0 = t0)}.  Here \code{tt} is
a vector of length B having i-th entry \code{tt[i] <- func(x[Ii,],
...)}, where x is the n x p data matrix and \code{Ii <-
sample(n,n,T)}, a bootstrap vector of indices. Y is a B x n "count"
matrix, whose i-th row is the counts corresponding to Ii. For
example if n = 5 and \code{Ii=(2,5,2,1,4)}, then \code{Yi =
(1,2,0,1,1)}. Having computed \code{Blist}, \code{bcajack2} is
invoked as \code{bcajack2(Blist)} without need to enter the
function func.
}
